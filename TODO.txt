TODO demo:
- countdown initial credit
- Cave of the Black Wolf: 
	cutscene finale
		wolf appears, i get near him and
		dialog wolf talks
		back to the mine, inside the basket to the right of the wolf
		"press right"
		basket starts moving right
		final demo screen
- azzera l' inventario: lascia 10 coins, 2 legna e 3 metallo magari

KS
foto tetra 
screenshots
gifs
trailer
check foto sui perk

POST DEMO:
- overworld improvements: see
	C:\Users\checc\ARROWS2\overworld e C:\Users\checc\ARROWS2\places
- tutorial for the buttons!
- qualche istante di pausa tra una bgm e l' altra da dentro al manage
- motherpl_blocked_cooldownè usato nello StateFittizio sull' updatecamera
	ma dovrebbe essere metodo a parte, dedicato a routine per frame
	che non insistono sulla cemera
- StateHospital per gurarsi e salvare.
- caricare la partita da titlescreen
- Overworld: sprite animate in  e animazione acque 
- Dialog: miglioramento pixelArt
- TitleScreen: 
	nave come sprite in movimento, 
	animazione 
		acque che per ora è ogni 2 px, farla ogni 1 perchè ha effetto miglioramento
		thunder animation
	cheatCode - la mia faccia col dito medio dopo il Konami	
- Oh no il villaggio è sotto attacco! sull' overworld vedo dei mostri attaccabili
 e appena ci vado contro entro in un place dal quale posso uscire solo se 
 uccido tutti i nemici presenti
 - scrigni
 - parti di gioco (direi non obbligatorie) sbloccabili solo su certi dispositivi
	tipo SuperGB o Color o DMG.

KNOWN ISSUES:
- mentre sono in caduta libera(no jump) posso saltare di nuovo. 
- camera overworld
- ripristino dei nemici al ritorno di stato (buggato per nemici dello stesso type);

NICE TO HAVE POST DEMO:
- titlescreen: la nave arriva dopo un po', avanza e rimpicciolisce verso largo
- disegnare un percorso che scimmiotta il 3d, in prospettiva verticale di profondità. 
	Attraversando un cancello ad es. e salendo di 8 pixel. 
	Prendere dal vecchio gioco come mettere lo sprite dietro i tiles.
- doppia freccia corre?
- Legna + metallo + powder = Frecce Esplosive!


ZGB HACKS:
Sprite.h
#define CUSTOM_DATA_SIZE 8
#define CUSTOM_DATA_SIZE 10


PAD2 sulla SNES, prendere spunto da:
			- https://github.com/gbdk-2020/gbdk-2020/blob/develop/gbdk-lib/examples/gb/sgb_pong/sgb_pong.c
			- https://github.com/gbdk-2020/gbdk-2020/blob/develop/gbdk-lib/examples/gb/sgb_multiplayer/sgb_multiplayer.c  

PNG2MAP
C:\Users\checc\GB\ZGB-2022.0\tools\png2map\
png2gbtiles.exe dialogmapintro.png -gbm -g -pal=mypal.pal
maypal.pal file di testo contenente solo le seguenti
#C6D783
#8DCD53
#2D632F
#11380F
ovviamente palette del Paint.NET con cui ho fatto il png contiene gli stessi codici, senza # e con FF iniziali per azzerare opacità
png 160x144



MODIFICA FONT
il font si può modificare andando in aggiunta di simboli. Considerando che con ala 2022.0 è
facile sostituire tiles su window, ha poco senso. Se comunque decicessi di farlo,
anzitutto bisogna pistolare le tile count del .gbr di font
Poi bisogna andare sul Print.c e modificare lo switch, aggiungendoci i case 
con gli index delle nuove tile che ho messo sul font.gbr


C:\GB\ZGBNEW\tools\romusage-main\bin\romusage.exe C:\GB\ZGBNEW\ZGB-template-master\Debug\ARROWS_Debug.noi -g

DISCORD MARKDOWN: ```c ```
	```c
	#include "SpriteManager.h"

#include "Scroll.h"
#include "BankManager.h"
#include <string.h>
#include "main.h"
#include "ZGBMain.h"

//Pool
UINT8 sprite_manager_sprites_mem[N_SPRITE_MANAGER_SPRITES * sizeof(Sprite)];
Sprite* sprite_manager_sprites[N_SPRITE_MANAGER_SPRITES];
DECLARE_STACK(sprite_manager_sprites_pool, N_SPRITE_MANAGER_SPRITES);

//Current sprites
DECLARE_VECTOR(sprite_manager_updatables, N_SPRITE_MANAGER_SPRITES);

UINT8 sprite_manager_removal_check;

INT16 last_sprite_loaded = 0;
UINT8 last_sprite_pal_loaded = 0;

void SpriteManagerReset() {
	UINT8 i;

	last_sprite_loaded = 128;
	last_sprite_pal_loaded = 0;

	//Call Destroy on all sprites still on the list
	for(i = 0u; i != sprite_manager_updatables[0]; ++ i) {
		THIS = sprite_manager_sprites[sprite_manager_updatables[i + 1]];
		PUSH_BANK(spriteBanks[THIS->type]);
				spriteDestroyFuncs[THIS->type]();
		POP_BANK;
	}

	//place all sprites on the pool
	StackClear(sprite_manager_sprites_pool);
	for(i = 0; i != N_SPRITE_MANAGER_SPRITES; ++i) {
		sprite_manager_sprites[i] = (Sprite*)&sprite_manager_sprites_mem[sizeof(Sprite) * (UINT16)i];
		StackPush(sprite_manager_sprites_pool, i);		
	}
	ClearOAMs();

	memset(spriteIdxs, 128, N_SPRITE_TYPES);

	//Clear the list of updatable sprites
	sprite_manager_updatables[0] = 0;
	sprite_manager_removal_check = 0;
}

extern UWORD ZGB_Fading_SPal[32];
void SpriteManagerLoad(UINT8 sprite_type) {
#ifdef CGB
	UINT8 i;
#endif
	if(spriteIdxs[sprite_type] != 128 || last_sprite_loaded < -127) //Already loaded or no room for this sprite
		return;

	PUSH_BANK(spriteDataBanks[sprite_type])
	
	const struct MetaSpriteInfo* data = spriteDatas[sprite_type];
	UINT8 n_tiles = data->num_tiles;
	UINT8 n_pals = data->num_palettes;

	last_sprite_loaded -= n_tiles;
	spriteIdxs[sprite_type] = last_sprite_loaded;
	UINT8 end = last_sprite_loaded + n_tiles;
	if((end - 1u) >= (UINT8)last_sprite_loaded) {
		set_sprite_data(last_sprite_loaded, n_tiles, data->data);
	} else {
		set_sprite_data(last_sprite_loaded, n_tiles - end, data->data);
		set_sprite_data(0, end, data->data + ((n_tiles - end) << 4));
	}

#ifdef CGB
	for(i = 0; i != last_sprite_pal_loaded; ++ i)
	{
		if(memcmp(&ZGB_Fading_SPal[i << 2], data->palettes, n_pals << 3) == 0)
			break;
	}

	//Load palettes
	spritePalsOffset[sprite_type] = i;
	if(i == last_sprite_pal_loaded)
	{
		SetPalette(SPRITES_PALETTE, last_sprite_pal_loaded, n_pals, data->palettes, _current_bank);
		last_sprite_pal_loaded += n_pals;
	}
#endif

	POP_BANK
}

Sprite* cachedSprite; //This has to be declared outside because of an LCC bug (easy to see with the Princess' Axe)
Sprite* SpriteManagerAdd(UINT8 sprite_type, UINT16 x, UINT16 y) {
	Sprite* sprite;
	UINT8 sprite_idx;
	UINT16 spriteIdxTmp; //Yes, another bug in the compiler forced me to change the type here to UINT16 instead of UINT8

	SpriteManagerLoad(sprite_type);
	
	sprite_idx = StackPop(sprite_manager_sprites_pool);
	sprite = sprite_manager_sprites[sprite_idx];
	sprite->type = sprite_type;
	sprite->marked_for_removal = 0;
	sprite->lim_x = 32u;
	sprite->lim_y = 32u;
	sprite->mirror = NO_MIRROR;

	VectorAdd(sprite_manager_updatables, sprite_idx);

	InitSprite(sprite, sprite_type);
	sprite->x = x;
	sprite->y = y;
	sprite->unique_id = SPRITE_UNIQUE_ID(x >> 3, (y + sprite->coll_h - 1) >> 3);

	//Before calling start THIS and THIS_IDX must be set
	cachedSprite = THIS;
	spriteIdxTmp = THIS_IDX;
	THIS = sprite;
	THIS_IDX = sprite_manager_updatables[0] - 1;
	PUSH_BANK(spriteBanks[sprite->type]);
		spriteStartFuncs[sprite->type]();
	POP_BANK;
	//And now they must be restored
	THIS = cachedSprite;
	THIS_IDX = spriteIdxTmp;
	return sprite;
}

void SpriteManagerRemove(int idx) {
	sprite_manager_removal_check = 1;
	sprite_manager_sprites[sprite_manager_updatables[idx + 1]]->marked_for_removal = 1;
}

void SpriteManagerRemoveSprite(Sprite* sprite) {
	UINT8 i;
	Sprite* s;
	for(i = 0u; i != sprite_manager_updatables[0]; ++i) {
		s = sprite_manager_sprites[sprite_manager_updatables[i + 1]];
		if(s == sprite) {
			SpriteManagerRemove(i);
			break;
		}
	}
}

void SpriteManagerFlushRemove() {
	//We must remove sprites in inverse order because everytime we remove one the vector shrinks and displaces all elements
	for(THIS_IDX = sprite_manager_updatables[0] - 1u; (UINT8)(THIS_IDX + 1u) != 0u; THIS_IDX --) {
		THIS = sprite_manager_sprites[sprite_manager_updatables[THIS_IDX + 1u]];
		if(THIS->marked_for_removal) {
			StackPush(sprite_manager_sprites_pool, sprite_manager_updatables[THIS_IDX + 1u]);
			VectorRemovePos(sprite_manager_updatables, THIS_IDX);
				
			PUSH_BANK(spriteBanks[THIS->type]);
				spriteDestroyFuncs[THIS->type]();
			POP_BANK;
		}
	}
	sprite_manager_removal_check = 0;
}

void SetBank(UINT8 bank) OLDCALL
{
bank;
__asm
	ldhl	sp,	#2
	ld	a, (hl)
//*bank_stack = bank;
	ld  (#__current_bank), a
//SWITCH_ROM_MBC1(bank);
	ld (#0x2000), a
__endasm;
}

extern UINT8* oam;
extern UINT8* oam0;
extern UINT8* oam1;
UINT8 THIS_IDX = 0;
Sprite* THIS = 0;
void SpriteManagerUpdate() {
	//SPRITEMANAGER_ITERATE(THIS_IDX, THIS) {
	SPRITEMANAGER_ITERATE(THIS) {
		if(!THIS->marked_for_removal) {
			//No need to call push and pop here, just change the current bank
			SetBank(spriteBanks[THIS->type]);

			spriteUpdateFuncs[THIS->type]();

			if(THIS == scroll_target)
				RefreshScroll();

			DrawSprite(); //this needs to be done using the sprite bank because the animation array is stored there
		}
	}

	SwapOAMs();

	if(sprite_manager_removal_check) {
		SpriteManagerFlushRemove();
	}
}

void SetSprite(Sprite* sprite, UINT8 si, UINT8 tile_index, UINT8* sd, UINT8 length, UINT8 palette_index, UINT8 flags) {
    SetSpriteInfo(sprite, si, tile_index, length / 16, palette_index, flags);
    UINT8* frames_vram_addr = VRAM_ALLOC(length);
    sprite->frames_vram_addr = frames_vram_addr;
    memcpy(frames_vram_addr, sd, length);
}

```

png2asset produces the human readable C files for the sprites/actors. 
nobody forbids you to look into those and make your own or tweak 
the results of the image conversion.
[11:47 PM]
When the sprite is loaded, there is a “base tile” variable 
somewhere in the structures that sprite manager operates. 
That is the tile id where your tile data for that sprite was loaded. 
Just load some other data over, starting from that tile id

FLYING ARROWS 4 
come Predator 2 per Sega Master System. Mi piace molto quella prospettiva lì. 
Ho notato che su Sega Master System tutti i giochi USGold sono disegnati molto bene. Se ce ne fosse uno con un po' di profondità...
come TMNT 3 sulla NES
Lone Ranger NES
Joe & Mac sulla grafica dei place.